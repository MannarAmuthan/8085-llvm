//===-- I8085ISelDAGToDAG.cpp - A dag to dag inst selector for I8085 ----------===//
//
// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
// See https://llvm.org/LICENSE.txt for license information.
// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
//
//===----------------------------------------------------------------------===//
//
// This file defines an instruction selector for the I8085 target.
//
//===----------------------------------------------------------------------===//

#include "I8085.h"
#include "I8085TargetMachine.h"
#include "MCTargetDesc/I8085MCTargetDesc.h"

#include "llvm/CodeGen/MachineRegisterInfo.h"
#include "llvm/CodeGen/SelectionDAGISel.h"
#include "llvm/Support/Debug.h"
#include "llvm/Support/raw_ostream.h"

#include <iostream>

#define DEBUG_TYPE "i8085-isel"

namespace llvm {

/// Lowers LLVM IR (in DAG form) to I8085 MC instructions (in DAG form).
class I8085DAGToDAGISel : public SelectionDAGISel {
public:
  static char ID;

  I8085DAGToDAGISel(I8085TargetMachine &TM, CodeGenOpt::Level OptLevel)
      : SelectionDAGISel(ID, TM, OptLevel), Subtarget(nullptr) {}

  StringRef getPassName() const override {
    return "I8085 DAG->DAG Instruction Selection";
  }

  bool runOnMachineFunction(MachineFunction &MF) override;

  bool SelectAddr(SDNode *Op, SDValue N, SDValue &Base, SDValue &Disp);


// Include the pieces autogenerated from the target description.
#include "I8085GenDAGISel.inc"

private:
  void Select(SDNode *N) override;
  bool trySelect(SDNode *N);

  template <unsigned NodeType> bool select(SDNode *N);

  const I8085Subtarget *Subtarget;
};

char I8085DAGToDAGISel::ID = 0;

bool I8085DAGToDAGISel::runOnMachineFunction(MachineFunction &MF) {
  Subtarget = &MF.getSubtarget<I8085Subtarget>();
  return SelectionDAGISel::runOnMachineFunction(MF);
}

bool I8085DAGToDAGISel::SelectAddr(SDNode *Op, SDValue N, SDValue &Base,
                                 SDValue &Disp) {
  SDLoc dl(Op);
  auto DL = CurDAG->getDataLayout();
  MVT PtrVT = getTargetLowering()->getPointerTy(DL);

  // if the address is a frame index get the TargetFrameIndex.
  if (const FrameIndexSDNode *FIN = dyn_cast<FrameIndexSDNode>(N)) {
    Base = CurDAG->getTargetFrameIndex(FIN->getIndex(), PtrVT);
    Disp = CurDAG->getTargetConstant(0, dl, MVT::i8);

    return true;
  }

  // Match simple Reg + uimm6 operands.
  if (N.getOpcode() != ISD::ADD && N.getOpcode() != ISD::SUB &&
      !CurDAG->isBaseWithConstantOffset(N)) {
    return false;
  }

  if (const ConstantSDNode *RHS = dyn_cast<ConstantSDNode>(N.getOperand(1))) {
    int RHSC = (int)RHS->getZExtValue();

    // Convert negative offsets into positives ones.
    if (N.getOpcode() == ISD::SUB) {
      RHSC = -RHSC;
    }

    // <#Frame index + const>
    // Allow folding offsets bigger than 63 so the frame pointer can be used
    // directly instead of copying it around by adjusting and restoring it for
    // each access.
    if (N.getOperand(0).getOpcode() == ISD::FrameIndex) {
      int FI = cast<FrameIndexSDNode>(N.getOperand(0))->getIndex();

      Base = CurDAG->getTargetFrameIndex(FI, PtrVT);
      Disp = CurDAG->getTargetConstant(RHSC, dl, MVT::i16);

      return true;
    }

    // The value type of the memory instruction determines what is the maximum
    // offset allowed.
    MVT VT = cast<MemSDNode>(Op)->getMemoryVT().getSimpleVT();

    // We only accept offsets that fit in 6 bits (unsigned).
    if (isUInt<6>(RHSC) && (VT == MVT::i8 || VT == MVT::i16)) {
      Base = N.getOperand(0);
      Disp = CurDAG->getTargetConstant(RHSC, dl, MVT::i8);

      return true;
    }
  }

  return false;
}

unsigned get8Opc(ISD::CondCode CC){
  unsigned Opc=0;
    switch(CC){
      case ISD::SETNE:
          Opc = I8085::SET_NE_8;
          break;
      
      case ISD::SETEQ:
          Opc = I8085::SET_EQ_8;
          break;

      case ISD::SETGE:
          Opc = I8085::SET_GE_8;
          break;

      case ISD::SETLE:
          Opc = I8085::SET_LE_8;
          break;

      case ISD::SETGT:
          Opc = I8085::SET_GT_8;
          break;

      case ISD::SETULT:
          Opc = I8085::SET_ULT_8;
          break;

      case ISD::SETUGE:
          Opc = I8085::SET_UGE_8;
          break;

      case ISD::SETULE:
          Opc = I8085::SET_ULE_8;
          break;

      case ISD::SETUGT:
          Opc = I8085::SET_UGT_8;
          break;

      case ISD::SETLT:
          Opc = I8085::SET_LT_8;
          break;    
  }
  return Opc;
}

unsigned get16Opc(ISD::CondCode CC){
  unsigned Opc=0;
    switch(CC){
      case ISD::SETNE:
          Opc = I8085::SET_NE_16;
          break;
      
      case ISD::SETEQ:
          Opc = I8085::SET_EQ_16;
          break;

      case ISD::SETGE:
          Opc = I8085::SET_GE_16;
          break;

      case ISD::SETLE:
          Opc = I8085::SET_LE_16;
          break;

      case ISD::SETGT:
          Opc = I8085::SET_GT_16;
          break;

      case ISD::SETLT:
          Opc = I8085::SET_LT_16;
          break;

      case ISD::SETULT:
          Opc = I8085::SET_ULT_16;
          break;

      case ISD::SETUGE:
          Opc = I8085::SET_UGE_16;
          break;

      case ISD::SETULE:
          Opc = I8085::SET_ULE_16;
          break;

      case ISD::SETUGT:
          Opc = I8085::SET_UGT_16;
          break;    
  }
  return Opc;
}

unsigned get32Opc(ISD::CondCode CC){
  unsigned Opc=0;
    switch(CC){
      case ISD::SETNE:
          Opc = I8085::SET_NE_32;
          break;
      
      case ISD::SETEQ:
          Opc = I8085::SET_EQ_32;
          break;

      case ISD::SETGE:
          Opc = I8085::SET_GE_32;
          break;

      case ISD::SETLE:
          Opc = I8085::SET_LE_32;
          break;

      case ISD::SETGT:
          Opc = I8085::SET_GT_32;
          break;

      case ISD::SETLT:
          Opc = I8085::SET_LT_32;
          break;

      case ISD::SETULT:
          Opc = I8085::SET_ULT_32;
          break;

      case ISD::SETUGE:
          Opc = I8085::SET_UGE_32;
          break;

      case ISD::SETULE:
          Opc = I8085::SET_ULE_32;
          break;

      case ISD::SETUGT:
          Opc = I8085::SET_UGT_32;
          break;    
  }
  return Opc;
}


template <> bool I8085DAGToDAGISel::select<ISD::SETCC>(SDNode *N) {
  SDLoc dl(N);
  auto DL = CurDAG->getDataLayout();

  ISD::CondCode CC = cast<CondCodeSDNode>(N->getOperand(2))->get();

  SDValue Lhs = N->getOperand(0);
  SDValue Rhs = N->getOperand(1);
  SDValue Ops[] = {Lhs,Rhs};
  
  unsigned Opc=get8Opc(CC);

  if(Lhs.getSimpleValueType() == MVT::i16){
    Opc=get16Opc(CC);
  }
  else if(Lhs.getSimpleValueType() == MVT::i32){
    Opc=get32Opc(CC);
  }

  SDNode *ResNode=CurDAG->getMachineNode(Opc, dl,MVT::i8,Ops);
  ReplaceUses(SDValue(N, 0), SDValue(ResNode, 0));
  CurDAG->RemoveDeadNode(N);
  return true;
}


template <> bool I8085DAGToDAGISel::select<ISD::BR_CC>(SDNode *N) {
  SDLoc dl(N);
  auto DL = CurDAG->getDataLayout();

  ISD::CondCode CC = cast<CondCodeSDNode>(N->getOperand(1))->get();

  SDValue Chain = N->getOperand(0);
  SDValue LHS = N->getOperand(2);
  SDValue RHS = N->getOperand(3);
  SDValue JumpTo = N->getOperand(4);
  
  unsigned Opc=get8Opc(CC);
  unsigned JumpOpc=I8085::JMP_8_IF;
  
  if(LHS.getSimpleValueType() == MVT::i16){
    Opc=get16Opc(CC);
  }
  else if(LHS.getSimpleValueType() == MVT::i32){
    Opc=get32Opc(CC);
  }

  SDNode *SETccNode=CurDAG->getMachineNode(Opc, dl,MVT::i8,{LHS,RHS});

  SDValue Ops[] = {SDValue(SETccNode, 0),JumpTo,Chain};
  
  SDNode *ResNode = CurDAG->getMachineNode(JumpOpc, dl,MVT::Other,Ops);
  ReplaceUses(SDValue(N, 0), SDValue(ResNode, 0));
  CurDAG->RemoveDeadNode(N);
  return true;
}

template <> bool I8085DAGToDAGISel::select<ISD::SHL>(SDNode *N) {
  SDLoc dl(N);
  auto DL = CurDAG->getDataLayout();

  SDValue LHS = N->getOperand(0);
  SDValue RHS = N->getOperand(1);
  
  
  if(LHS.getSimpleValueType() == MVT::i8 && RHS.getSimpleValueType() == MVT::i8){
    unsigned Opc=I8085::SHL_8;
    SDValue Ops[] = {LHS,RHS};
    SDNode *ResNode = CurDAG->getMachineNode(Opc, dl,MVT::i8,Ops);
    ReplaceUses(SDValue(N, 0), SDValue(ResNode, 0));
    CurDAG->RemoveDeadNode(N);
    return true;
  }

  return false;
}

template <> bool I8085DAGToDAGISel::select<ISD::SRA>(SDNode *N) {
  SDLoc dl(N);
  auto DL = CurDAG->getDataLayout();

  SDValue LHS = N->getOperand(0);
  SDValue RHS = N->getOperand(1);
  
  
  if(LHS.getSimpleValueType() == MVT::i8 && RHS.getSimpleValueType() == MVT::i8){
    unsigned Opc=I8085::SRA_8;
    SDValue Ops[] = {LHS,RHS};
    SDNode *ResNode = CurDAG->getMachineNode(Opc, dl,MVT::i8,Ops);
    ReplaceUses(SDValue(N, 0), SDValue(ResNode, 0));
    CurDAG->RemoveDeadNode(N);
    return true;
  }

  return false;
}


template <> bool I8085DAGToDAGISel::select<ISD::FrameIndex>(SDNode *N) {
  auto DL = CurDAG->getDataLayout();

  // Convert the frameindex into a temp instruction that will hold the
  // effective address of the final stack slot.
  int FI = cast<FrameIndexSDNode>(N)->getIndex();
  SDValue TFI =
      CurDAG->getTargetFrameIndex(FI, getTargetLowering()->getPointerTy(DL));

  CurDAG->SelectNodeTo(N, I8085::FRMIDX, getTargetLowering()->getPointerTy(DL),
                       TFI, CurDAG->getTargetConstant(0, SDLoc(N), MVT::i16));
  return true;
}

void I8085DAGToDAGISel::Select(SDNode *N) {
  // If we have a custom node, we already have selected!
  if (N->isMachineOpcode()) {
    LLVM_DEBUG(errs() << "== "; N->dump(CurDAG); errs() << "\n");
    N->setNodeId(-1);
    return;
  }
  
  // See if subclasses can handle this node.
  if (trySelect(N))
    return;

  // Select the default instruction
  SelectCode(N);
}

bool I8085DAGToDAGISel::trySelect(SDNode *N) {
  unsigned Opcode = N->getOpcode();
  SDLoc DL(N);

  switch (Opcode) {
  case ISD::SETCC:
    return select<ISD::SETCC>(N);
  case ISD::BR_CC:
    return select<ISD::BR_CC>(N);
  case ISD::SHL:
    return select<ISD::SHL>(N);  
  case ISD::SRA:
    return select<ISD::SRA>(N);
  case ISD::FrameIndex:
    return select<ISD::FrameIndex>(N);    
  default:
    return false;
  }
}

FunctionPass *createI8085ISelDag(I8085TargetMachine &TM,
                               CodeGenOpt::Level OptLevel) {
  return new I8085DAGToDAGISel(TM, OptLevel);
}

} 